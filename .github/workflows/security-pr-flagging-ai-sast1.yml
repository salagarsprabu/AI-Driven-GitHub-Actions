# .github/workflows/security-pr-flagging-ai-sast.yml
name: Security PR Flagging - AI + Rules-based SAST

# Runs on PR events
on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write
  statuses: write
  models: read

env:
  # Change to "false" if you only want warnings and do not want to block merges
  BLOCK_ON_WARNINGS: "true"
  # Treat regex "high severity" matches as immediate blockers
  BLOCK_ON_HIGH_SEVERITY_REGEX: "true"
  # GitHub Model to use
  GH_MODEL: "gpt-4o-mini"
  # Temperature 0 for deterministic security results
  MODEL_TEMPERATURE: 0

jobs:
  security-scan:
    name: AI-assisted SAST (rules + GitHub model)
    runs-on: ubuntu-latest
    steps:

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install small tools (rg, jq, gh)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y ripgrep jq procps curl ca-certificates
          # Install github CLI if not present
          if ! command -v gh >/dev/null 2>&1; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
              | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
              | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi
          gh --version || true
          rg --version || true
          jq --version || true

      - name: Fetch base branch
        run: |
          # Ensure we have the base ref locally (needed for a three-dot diff)
          git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }} || true

      - name: Save PR diff (used by AI)
        run: |
          # Save a zero-context diff for AI analysis
          git diff origin/${{ github.event.pull_request.base.ref }}...HEAD -U0 > pr_diff.txt || true
          echo "=== DIFF START ===" > pr_diff_headline.txt
          head -n 50 pr_diff.txt >> pr_diff_headline.txt || true
          echo "" >> pr_diff_headline.txt
          echo "Changed files:" >> pr_diff_headline.txt
          git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD >> pr_diff_headline.txt || true

      - name: Get list of changed files
        id: files
        run: |
          git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD > changed_files.txt || true
          wc -l changed_files.txt || true
          # export multiline CHANGED_FILES into GITHUB_ENV
          echo "CHANGED_FILES<<EOF" >> $GITHUB_ENV
          cat changed_files.txt >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV


      ####################################################################
      # Rules-based (regex) scanner (fast)
      ####################################################################
      - name: Rules-based regex scan (fast)
        id: regexscan
        run: |
          set -uo pipefail

          # create fallback results file
          jq -n '{high:[], low:[]}' > regex_results.json

          # Write CHANGED_FILES into a temp file (read from env)
          printf "%s\n" "$CHANGED_FILES" > /tmp/changed_files_list.txt

          if [ ! -s /tmp/changed_files_list.txt ]; then
            echo "::warning::No changed files detected."
            echo "{}" > regex_results.json
            exit 0
          fi

          # HIGH severity patterns (immediate secrets / private keys / tokens)
          HIGH_PATTERNS=(
            '[A-Za-z0-9/+=]{40}'                         # generic long-looking secrets (rough)
            'AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}'          # AWS access key id
            '-----BEGIN (RSA|PRIVATE|EC|OPENSSH) PRIVATE KEY-----'
            "(password|passwd)[\"']?\s*[:=]\s*['\"].{3,}"
            '([A-Fa-f0-9]{32,})'                         # long hex-ish blobs
          )

          # LOW severity patterns
          LOW_PATTERNS=(
            '\beval\(|\bexec\('
            '["'\'']\s*\+\s*\w+\s*\+\s*["'\'']'          # simple string + var + string concat
            'rejectUnauthorized\s*[:=]\s*false|verify=False'
            'api[_-]?key|secret[_-]?key'
          )

          while IFS= read -r file; do
            # skip blanks and deleted files
            if [ -z "$file" ] || [ ! -f "$file" ]; then
              continue
            fi

            # skip binary-ish file types quickly
            case "$file" in
              *.png|*.jpg|*.jpeg|*.gif|*.pdf|*.zip|*.bin) continue ;;
            esac

            # HIGH patterns
            for pat in "${HIGH_PATTERNS[@]}"; do
              rg --no-filename -n --pcre2 "$pat" "$file" 2>/dev/null | while IFS=: read -r line content; do
                snippet=$(printf '%s' "$content" | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//')
                jq --arg f "$file" --arg l "$line" --arg m "$snippet" --arg p "$pat" '.high += [{"file":$f,"line":$l,"snippet":$m,"pattern":$p}]' regex_results.json > /tmp/rr.json && mv /tmp/rr.json regex_results.json
              done
            done

            # LOW patterns
            for pat in "${LOW_PATTERNS[@]}"; do
              rg --no-filename -n --pcre2 "$pat" "$file" 2>/dev/null | while IFS=: read -r line content; do
                snippet=$(printf '%s' "$content" | sed 's/"/\\"/g' | sed 's/^[[:space:]]*//')
                jq --arg f "$file" --arg l "$line" --arg m "$snippet" --arg p "$pat" '.low += [{"file":$f,"line":$l,"snippet":$m,"pattern":$p}]' regex_results.json > /tmp/rr.json && mv /tmp/rr.json regex_results.json
              done
            done

          done < /tmp/changed_files_list.txt

          # Expose results to environment for downstream steps
          cat regex_results.json
          echo "REGEX_RESULTS<<'JSON'" >> $GITHUB_ENV
          cat regex_results.json >> $GITHUB_ENV
          echo "JSON" >> $GITHUB_ENV

      ####################################################################
      # AI analysis: use PR diff to let the model look for logic issues
      ####################################################################
      - name: AI Security Analysis (GitHub model)
        id: ai
        env:
          GH_MODEL: ${{ env.GH_MODEL }}
          MODEL_TEMPERATURE: ${{ env.MODEL_TEMPERATURE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -uo pipefail

          DIFF_FILE=pr_diff.txt
          if [ ! -s "$DIFF_FILE" ]; then
            echo "::warning::Empty diff; nothing to analyze with AI."
            echo "NO_RISK" > ai_analysis.txt
            echo "AI_ANALYSIS<<'TXT'" >> $GITHUB_ENV
            cat ai_analysis.txt >> $GITHUB_ENV
            echo "TXT" >> $GITHUB_ENV
            exit 0
          fi

  
          read -r -d '' SYSTEM_PROMPT <<'PROMPT' || true
          You are a strict security reviewer specialized in code-level security. Analyze the provided PR diff and:
          - Identify any risky security patterns (bypassed authentication/authorization, insecure input validation, SQL injection, command injection, unsafe `eval`/`exec`, insecure deserialization, hardcoded credentials, use of weak crypto/incorrect TLS handling).
          - For each finding, emit a JSON list of objects with fields: "severity" (HIGH|MEDIUM|LOW), "summary", "file", "line_hint" (if available), and "explain" (one short sentence).
          - If no risky patterns are found, output the single token: NO_RISK
          Respond ONLY with valid JSON or the token NO_RISK.
          PROMPT


          # Ensure gh is authenticated (GH CLI will pick up GITHUB_TOKEN in Actions)
          gh auth status >/dev/null 2>&1 || true

          # Build GraphQL payload using jq to safely embed the prompt and diff
          INPUT_JSON=$(jq -nc --arg model "$GH_MODEL" --argjson temp "$MODEL_TEMPERATURE" --arg sys "$SYSTEM_PROMPT" --arg diff "$(cat pr_diff.txt)" '{
            model: $model,
            temperature: $temp,
            messages: [
              {role:"system", content: $sys},
              {role:"user", content: $diff}
            ],
            max_tokens: 1200
          }')

          # Call GitHub CreateChatCompletion GraphQL API via gh
          RESPONSE=$(gh api graphql -f query='
            mutation($input: CreateChatCompletionInput!) {
              createChatCompletion(input: $input) {
                message {
                  content
                }
              }
            }' -F input="$INPUT_JSON" --jq '.data.createChatCompletion.message.content' 2>/dev/null || true)

          # Save output
          echo "${RESPONSE:-}" > ai_analysis.txt || true
          echo "AI_ANALYSIS<<'TXT'" >> $GITHUB_ENV
          cat ai_analysis.txt >> $GITHUB_ENV
          echo "TXT" >> $GITHUB_ENV

          # Print to logs
          echo "=== AI OUTPUT START ==="
          sed -n '1,200p' ai_analysis.txt || true
          echo "=== AI OUTPUT END ==="

      ####################################################################
      # Aggregate results, fail or warn, and leave a PR comment
      ####################################################################
      - name: Aggregate & decide (fail on policy)
        id: decide
        env:
          BLOCK_ON_WARNINGS: ${{ env.BLOCK_ON_WARNINGS }}
          BLOCK_ON_HIGH_SEVERITY_REGEX: ${{ env.BLOCK_ON_HIGH_SEVERITY_REGEX }}
        run: |
          set -uo pipefail

          REGEX_JSON="$REGEX_RESULTS"
          AI_OUT="$AI_ANALYSIS"

          summary_file=security_summary.md
          echo "# Security Analysis Report" > $summary_file
          echo "" >> $summary_file
          echo "Generated by: rules-based scanner + GitHub model" >> $summary_file
          echo "" >> $summary_file

          echo "## Rules-based scanner findings" >> $summary_file
          echo "" >> $summary_file

          if [ "$(echo "$REGEX_JSON" | jq -r '.high | length')" -gt 0 ]; then
            echo "### HIGH severity (regex)" >> $summary_file
            echo "" >> $summary_file
            echo "$REGEX_JSON" | jq -r '.high[] | "- `\(.file):\(.line)` ‚Äî \(.pattern) ‚Äî snippet: ``\(.snippet|gsub("\n";" "))``"' >> $summary_file
            echo "" >> $summary_file
          else
            echo "- No HIGH severity regex matches found." >> $summary_file
            echo "" >> $summary_file
          fi

          if [ "$(echo "$REGEX_JSON" | jq -r '.low | length')" -gt 0 ]; then
            echo "### LOW/INFO severity (regex)" >> $summary_file
            echo "" >> $summary_file
            echo "$REGEX_JSON" | jq -r '.low[] | "- `\(.file):\(.line)` ‚Äî \(.pattern) ‚Äî snippet: ``\(.snippet|gsub("\n";" "))``"' >> $summary_file
            echo "" >> $summary_file
          else
            echo "- No LOW severity regex matches found." >> $summary_file
            echo "" >> $summary_file
          fi

          echo "## AI model findings" >> $summary_file
          echo "" >> $summary_file

          if echo "$AI_OUT" | grep -q '^NO_RISK$'; then
            echo "- AI model: NO_RISK" >> $summary_file
          else
            if echo "$AI_OUT" | jq -e . >/dev/null 2>&1; then
              echo "$AI_OUT" | jq -r '.[] | "- [\(.severity)] \(.summary) (\(.file // "unknown"): \(.line_hint // "-")) ‚Äî \(.explain)"' >> $summary_file
            else
              echo "#### AI raw output (unexpected format):" >> $summary_file
              echo '```' >> $summary_file
              # include raw but truncated to avoid giant comments
              head -n 200 ai_analysis.txt >> $summary_file || true
              echo '```' >> $summary_file
            fi
          fi

          echo "" >> $summary_file

          # Export summary for the PR-comment step via GITHUB_ENV
          echo "SECURITY_SUMMARY<<'MD'" >> $GITHUB_ENV
          cat $summary_file >> $GITHUB_ENV
          echo "MD" >> $GITHUB_ENV

          # Decide blocking logic
          BLOCK_REASON=""

          if [ "$(echo "$REGEX_JSON" | jq -r '.high | length')" -gt 0 ] && [ "${BLOCK_ON_HIGH_SEVERITY_REGEX}" = "true" ]; then
            BLOCK_REASON="High severity regex findings"
          fi

          if ! echo "$AI_OUT" | grep -q '^NO_RISK$' && [ "${BLOCK_ON_WARNINGS}" = "true" ]; then
            if [ -z "$BLOCK_REASON" ]; then
              BLOCK_REASON="AI-detected security findings"
            else
              BLOCK_REASON="$BLOCK_REASON; AI also reported findings"
            fi
          fi

          if [ -n "$BLOCK_REASON" ]; then
            echo "BLOCK=true" >> $GITHUB_ENV
            echo "BLOCK_REASON=$BLOCK_REASON" >> $GITHUB_ENV
            echo "::error title=Security check blocked::${BLOCK_REASON}"
          else
            echo "BLOCK=false" >> $GITHUB_ENV
            echo "::notice::No blocking security findings detected."
          fi

      - name: Post comment on PR with results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const body = process.env.SECURITY_SUMMARY || "No summary generated.";
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: `üîê **Automated Security Report**\n\n${body}\n\n---\n*This check is automated: rules-based scanner + GitHub Model.*`
            });

      # Final step: fail the job if we determined we must block
      - name: Fail job if blocking policy triggered
        if: always()
        run: |
          if [ "${BLOCK:-false}" = "true" ]; then
            echo "Failing job due to: ${BLOCK_REASON}"
            exit 1
          else
            echo "No blocking findings. Job will pass."
          fi
